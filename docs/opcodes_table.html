<!DOCTYPE html>
<html>
    <head>
        <title>Opcodes table</title>
        <meta charset="utf-8">
        <style>
            table {
                border-collapse: collapse;
                margin: 14px;
            }
            
            th, td {
                padding: 3px;
                border: 1px solid #ccc;
            }
        
            .changed {
                background: #AB3535;
            }
        </style>
    </head>
    <body>
        <h1>Opcodes of the Hermes virtual machine</h1>
        <p>With the opcode byte value indicated respective to each stable version of the React Native Hermes VM bytecode format, as well as the auto-generated documentation from the "BytecodeList.def" file from the Hermes VM source tree.</p>
        <p>This list of opcodes is used by the <a href="https://github.com/P1sec/hermes-dec" target="_blank">hermes-dec</a> open-source reverse engineering project.</p>
        <table>
            <thead>
                <tr>
                    <th>Instruction</th>
                    <th colspan="11">Bytecode version to opcode</th>
                    <th>Documentation</th>
                </tr>
                <tr>
                    <th></th>
                    <th>51</th><th>58</th><th>59</th><th>60</th><th>62</th><th>71</th><th>74</th><th>76</th><th>83</th><th>84</th><th>89</th>
                    <th></th>
                </tr>
            </thead>
            <tbody>
<tr>
        <td>Add</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (JS addition/concatenation)">22</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 + Arg3 (JS addition/concatenation)</td>
    </tr><tr>
        <td>Add32</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (32-bit integer addition)">185</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (32-bit integer addition)">190</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 + Arg3 (32-bit integer addition)</td>
    </tr><tr>
        <td>AddEmptyString</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">113</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">115</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">116</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">116</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">116</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">116</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">116</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">116</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">121</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">121</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a string as if evaluating the expression:
Arg1 = &quot;&quot; + Arg2
In practice this means
Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))
with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).">126</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Convert a value to a string as if evaluating the expression:<br>Arg1 = &quot;&quot; + Arg2<br>In practice this means<br>Arg1 = ToString(ToPrimitive(Arg2, PreferredType::NONE))<br>with ToPrimitive (ES5.1 9.1) and ToString (ES5.1 9.8).</td>
    </tr><tr>
        <td>AddN</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">22</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)">23</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 + Arg3 (Numeric addition, skips number check)</td>
    </tr><tr>
        <td>AsyncBreakCheck</td><td></td><td></td><td></td><td></td><td title=" (total size 0)

Fast check for an async interrupt request.">91</td><td title=" (total size 0)

Fast check for an async interrupt request.">91</td><td title=" (total size 0)

Fast check for an async interrupt request.">91</td><td title=" (total size 0)

Fast check for an async interrupt request.">91</td><td title=" (total size 0)

Fast check for an async interrupt request.">94</td><td title=" (total size 0)

Fast check for an async interrupt request.">94</td><td title=" (total size 0)

Fast check for an async interrupt request.">96</td>
        <td> (total size 0)<br><br>Fast check for an async interrupt request.</td>
    </tr><tr>
        <td>BitAnd</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)">34</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 &amp; Arg3 (JS bitwise AND)</td>
    </tr><tr>
        <td>BitNot</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = ~Arg2 (Bitwise not)">12</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Arg1 = ~Arg2 (Bitwise not)</td>
    </tr><tr>
        <td>BitOr</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 | Arg3 (JS bitwise OR)">36</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 | Arg3 (JS bitwise OR)</td>
    </tr><tr>
        <td>BitXor</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">34</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">35</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)">35</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 ^ Arg3 (JS bitwise XOR)</td>
    </tr><tr>
        <td>Call</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">74</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">74</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">74</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">74</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">74</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">74</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">74</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">74</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a function.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">77</td>
        <td>Reg8, Reg8, UInt8 (total size 3)<br><br>Call a function.<br>Arg1 is the destination of the return value.<br>Arg2 is the closure to invoke.<br>Arg3 is the number of arguments, assumed to be found in reverse order<br>from the end of the current frame.</td>
    </tr><tr>
        <td>Call1</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">76</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">76</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">76</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">76</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">76</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">76</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">76</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">76</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">77</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">77</td><td title="Reg8, Reg8, Reg8 (total size 3)

Call a function with one arg.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.">79</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Call a function with one arg.<br>Arg1 is the destination of the return value.<br>Arg2 is the closure to invoke.<br>Arg3 is the first argument.</td>
    </tr><tr>
        <td>Call2</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">78</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">78</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">78</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">78</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">78</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">78</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">78</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">78</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Call a function with two args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.">81</td>
        <td>Reg8, Reg8, Reg8, Reg8 (total size 4)<br><br>Call a function with two args.<br>Arg1 is the destination of the return value.<br>Arg2 is the closure to invoke.<br>Arg3 is the first argument.<br>Arg4 is the second argument.</td>
    </tr><tr>
        <td>Call3</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">79</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Call a function with three args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.">82</td>
        <td>Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)<br><br>Call a function with three args.<br>Arg1 is the destination of the return value.<br>Arg2 is the closure to invoke.<br>Arg3 is the first argument.<br>Arg4 is the second argument.<br>Arg5 is the third argument.</td>
    </tr><tr>
        <td>Call4</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">80</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">81</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">81</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)

Call a function with four args.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the first argument.
Arg4 is the second argument.
Arg5 is the third argument.
Arg6 is the fourth argument.">83</td>
        <td>Reg8, Reg8, Reg8, Reg8, Reg8, Reg8 (total size 6)<br><br>Call a function with four args.<br>Arg1 is the destination of the return value.<br>Arg2 is the closure to invoke.<br>Arg3 is the first argument.<br>Arg4 is the second argument.<br>Arg5 is the third argument.<br>Arg6 is the fourth argument.</td>
    </tr><tr>
        <td>CallBuiltin</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">84</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">84</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">84</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">84</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">84</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.">84</td><td class="changed" title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.
thisArg is set to &quot;undefined&quot;.">84</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.
thisArg is set to &quot;undefined&quot;.">84</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.
thisArg is set to &quot;undefined&quot;.">85</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.
thisArg is set to &quot;undefined&quot;.">85</td><td title="Reg8, UInt8, UInt8 (total size 3)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.
thisArg is set to &quot;undefined&quot;.">87</td>
        <td>Reg8, UInt8, UInt8 (total size 3)<br><br>Call a builtin function.<br>Note this is NOT marked as a Ret target, because the callee is native<br>and therefore never JS.<br>Arg1 is the destination of the return value.<br>Arg2 is the builtin number.<br>Arg3 is the number of arguments, assumed to be found in reverse order<br>from the end of the current frame.<br>thisArg is set to &quot;undefined&quot;.</td>
    </tr><tr>
        <td>CallBuiltinLong</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, UInt8, UInt32 (total size 6)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.
thisArg is set to &quot;undefined&quot;.">86</td><td title="Reg8, UInt8, UInt32 (total size 6)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.
thisArg is set to &quot;undefined&quot;.">86</td><td title="Reg8, UInt8, UInt32 (total size 6)

Call a builtin function.
Note this is NOT marked as a Ret target, because the callee is native
and therefore never JS.
Arg1 is the destination of the return value.
Arg2 is the builtin number.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame.
thisArg is set to &quot;undefined&quot;.">88</td>
        <td>Reg8, UInt8, UInt32 (total size 6)<br><br>Call a builtin function.<br>Note this is NOT marked as a Ret target, because the callee is native<br>and therefore never JS.<br>Arg1 is the destination of the return value.<br>Arg2 is the builtin number.<br>Arg3 is the number of arguments, assumed to be found in reverse order<br>from the end of the current frame.<br>thisArg is set to &quot;undefined&quot;.</td>
    </tr><tr>
        <td>CallDirect</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">77</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">77</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">77</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">77</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">77</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">77</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">77</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">77</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">78</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">78</td><td title="Reg8, UInt8, UInt16 (function_id) (total size 4)

Call a function directly without a closure.
Arg1 is the destination of the return value.
Arg2 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.
Arg3 is index in the function table.
Note that we expect the variable-sized argument to be last.">80</td>
        <td>Reg8, UInt8, UInt16 (function_id) (total size 4)<br><br>Call a function directly without a closure.<br>Arg1 is the destination of the return value.<br>Arg2 is the number of arguments, assumed to be found in reverse order<br>from the end of the current frame. The first argument &#x27;this&#x27;<br>is assumed to be created with CreateThis.<br>Arg3 is index in the function table.<br>Note that we expect the variable-sized argument to be last.</td>
    </tr><tr>
        <td>CallDirectLongIndex</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">83</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">83</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">83</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">83</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">83</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">83</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">83</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">83</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">84</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">84</td><td title="Reg8, UInt8, UInt32 (total size 6)

Identical to CallDirect, but the function index is 32-bit.">86</td>
        <td>Reg8, UInt8, UInt32 (total size 6)<br><br>Identical to CallDirect, but the function index is 32-bit.</td>
    </tr><tr>
        <td>CallLong</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">81</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">81</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">81</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">81</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">81</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">81</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">81</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">81</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Call, but allowing more arguments.">84</td>
        <td>Reg8, Reg8, UInt32 (total size 6)<br><br>Identical to Call, but allowing more arguments.</td>
    </tr><tr>
        <td>Catch</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">86</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">86</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">86</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">86</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">86</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">86</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">86</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">86</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">89</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">89</td><td title="Reg8 (total size 1)

Catch an exception (the first instruction in an exception handler).
} catch(Arg1) {">91</td>
        <td>Reg8 (total size 1)<br><br>Catch an exception (the first instruction in an exception handler).<br>} catch(Arg1) {</td>
    </tr><tr>
        <td>CoerceThisNS</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">109</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">111</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">112</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">112</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">112</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">112</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">112</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">112</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">117</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">117</td><td title="Reg8, Reg8 (total size 2)

Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict
mode rules. Primitives are boxed, \c null or \c undefed produce the global
object.
Arg1 = coerce_to_object(Arg2)">121</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Coerce a value assumed to contain &#x27;this&#x27; to an object using non-strict<br>mode rules. Primitives are boxed, \c null or \c undefed produce the global<br>object.<br>Arg1 = coerce_to_object(Arg2)</td>
    </tr><tr>
        <td>CompleteGenerator</td><td></td><td title=" (total size 0)

Set the generator status to complete, but do not return.">123</td><td title=" (total size 0)

Set the generator status to complete, but do not return.">124</td><td title=" (total size 0)

Set the generator status to complete, but do not return.">124</td><td title=" (total size 0)

Set the generator status to complete, but do not return.">124</td><td title=" (total size 0)

Set the generator status to complete, but do not return.">124</td><td title=" (total size 0)

Set the generator status to complete, but do not return.">124</td><td title=" (total size 0)

Set the generator status to complete, but do not return.">124</td><td title=" (total size 0)

Set the generator status to complete, but do not return.">129</td><td title=" (total size 0)

Set the generator status to complete, but do not return.">129</td><td title=" (total size 0)

Set the generator status to complete, but do not return.">134</td>
        <td> (total size 0)<br><br>Set the generator status to complete, but do not return.</td>
    </tr><tr>
        <td>Construct</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">75</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">76</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">76</td><td title="Reg8, Reg8, UInt8 (total size 3)

Call a constructor, with semantics identical to Call.
Arg1 is the destination of the return value.
Arg2 is the closure to invoke.
Arg3 is the number of arguments, assumed to be found in reverse order
from the end of the current frame. The first argument &#x27;this&#x27;
is assumed to be created with CreateThis.">78</td>
        <td>Reg8, Reg8, UInt8 (total size 3)<br><br>Call a constructor, with semantics identical to Call.<br>Arg1 is the destination of the return value.<br>Arg2 is the closure to invoke.<br>Arg3 is the number of arguments, assumed to be found in reverse order<br>from the end of the current frame. The first argument &#x27;this&#x27;<br>is assumed to be created with CreateThis.</td>
    </tr><tr>
        <td>ConstructLong</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">82</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">83</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">83</td><td title="Reg8, Reg8, UInt32 (total size 6)

Identical to Construct, but allowing more arguments.">85</td>
        <td>Reg8, Reg8, UInt32 (total size 6)<br><br>Identical to Construct, but allowing more arguments.</td>
    </tr><tr>
        <td>CreateAsyncClosure</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for an AsyncFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">100</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for an AsyncFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">100</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for an AsyncFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">102</td>
        <td>Reg8, Reg8, UInt16 (function_id) (total size 4)<br><br>Create a closure for an AsyncFunction.<br>Arg1 is the register in which to store the closure.<br>Arg2 is the current environment as loaded by GetEnvironment 0.<br>Arg3 is index in the function table.</td>
    </tr><tr>
        <td>CreateAsyncClosureLongIndex</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for an AsyncFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">101</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for an AsyncFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">101</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for an AsyncFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">103</td>
        <td>Reg8, Reg8, UInt32 (function_id) (total size 6)<br><br>Create a closure for an AsyncFunction.<br>Arg1 is the register in which to store the closure.<br>Arg2 is the current environment as loaded by GetEnvironment 0.<br>Arg3 is index in the function table.</td>
    </tr><tr>
        <td>CreateClosure</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">93</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">93</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">94</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">94</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">94</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">94</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">94</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">94</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">96</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">96</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">98</td>
        <td>Reg8, Reg8, UInt16 (function_id) (total size 4)<br><br>Create a closure.<br>Arg1 is the register in which to store the closure.<br>Arg2 is the current environment as loaded by GetEnvironment 0.<br>Arg3 is index in the function table.</td>
    </tr><tr>
        <td>CreateClosureLongIndex</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">94</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">94</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">95</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">95</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">95</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">95</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">95</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">95</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">97</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">97</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">99</td>
        <td>Reg8, Reg8, UInt32 (function_id) (total size 6)<br><br>Create a closure.<br>Arg1 is the register in which to store the closure.<br>Arg2 is the current environment as loaded by GetEnvironment 0.<br>Arg3 is index in the function table.</td>
    </tr><tr>
        <td>CreateEnvironment</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">47</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">47</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">47</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">47</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">47</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">47</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">47</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">47</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">48</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">48</td><td title="Reg8 (total size 1)

Create a new environment, to store values captured by closures.">50</td>
        <td>Reg8 (total size 1)<br><br>Create a new environment, to store values captured by closures.</td>
    </tr><tr>
        <td>CreateGenerator</td><td></td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">124</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">125</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">125</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">125</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">125</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">125</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">125</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">130</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">130</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">135</td>
        <td>Reg8, Reg8, UInt16 (function_id) (total size 4)<br><br>Create a generator.<br>Arg1 is the register in which to store the generator.<br>Arg2 is the current environment as loaded by GetEnvironment 0.<br>Arg3 is index in the function table.</td>
    </tr><tr>
        <td>CreateGeneratorClosure</td><td></td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">95</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">96</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">96</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">96</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">96</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">96</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">96</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">98</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">98</td><td title="Reg8, Reg8, UInt16 (function_id) (total size 4)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">100</td>
        <td>Reg8, Reg8, UInt16 (function_id) (total size 4)<br><br>Create a closure for a GeneratorFunction.<br>Arg1 is the register in which to store the closure.<br>Arg2 is the current environment as loaded by GetEnvironment 0.<br>Arg3 is index in the function table.</td>
    </tr><tr>
        <td>CreateGeneratorClosureLongIndex</td><td></td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">96</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">97</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">97</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">97</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">97</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">97</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">97</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">99</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">99</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a closure for a GeneratorFunction.
Arg1 is the register in which to store the closure.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">101</td>
        <td>Reg8, Reg8, UInt32 (function_id) (total size 6)<br><br>Create a closure for a GeneratorFunction.<br>Arg1 is the register in which to store the closure.<br>Arg2 is the current environment as loaded by GetEnvironment 0.<br>Arg3 is index in the function table.</td>
    </tr><tr>
        <td>CreateGeneratorLongIndex</td><td></td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">125</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">126</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">126</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">126</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">126</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">126</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">126</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">131</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">131</td><td title="Reg8, Reg8, UInt32 (function_id) (total size 6)

Create a generator.
Arg1 is the register in which to store the generator.
Arg2 is the current environment as loaded by GetEnvironment 0.
Arg3 is index in the function table.">136</td>
        <td>Reg8, Reg8, UInt32 (function_id) (total size 6)<br><br>Create a generator.<br>Arg1 is the register in which to store the generator.<br>Arg2 is the current environment as loaded by GetEnvironment 0.<br>Arg3 is index in the function table.</td>
    </tr><tr>
        <td>CreateRegExp</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">117</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">119</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">120</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">120</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">120</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">120</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">120</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">120</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">125</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">125</td><td title="Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)

Create a regular expression.
Arg1 is the result.
Arg2 is the string index of the pattern.
Arg3 is the string index of the flags.
Arg4 is the regexp bytecode index in the regexp table.">130</td>
        <td>Reg8, UInt32 (string_id), UInt32 (string_id), UInt32 (total size 13)<br><br>Create a regular expression.<br>Arg1 is the result.<br>Arg2 is the string index of the pattern.<br>Arg3 is the string index of the flags.<br>Arg4 is the regexp bytecode index in the regexp table.</td>
    </tr><tr>
        <td>CreateThis</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">95</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">97</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">98</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">98</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">98</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">98</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">98</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">98</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">102</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">102</td><td title="Reg8, Reg8, Reg8 (total size 3)

Allocate an empty, uninitialized object (immediately before a constructor).
Arg1 is the destination register.
Arg2 is the prototype to assign it.
Arg3 is the constructor closure that will be used*.
* To allow internal constructors to have special objects allocated.">104</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Allocate an empty, uninitialized object (immediately before a constructor).<br>Arg1 is the destination register.<br>Arg2 is the prototype to assign it.<br>Arg3 is the constructor closure that will be used*.<br>* To allow internal constructors to have special objects allocated.</td>
    </tr><tr>
        <td>Debugger</td><td title=" (total size 0)

Implementation dependent debugger action.">89</td><td title=" (total size 0)

Implementation dependent debugger action.">89</td><td title=" (total size 0)

Implementation dependent debugger action.">90</td><td title=" (total size 0)

Implementation dependent debugger action.">90</td><td title=" (total size 0)

Implementation dependent debugger action.">90</td><td title=" (total size 0)

Implementation dependent debugger action.">90</td><td title=" (total size 0)

Implementation dependent debugger action.">90</td><td title=" (total size 0)

Implementation dependent debugger action.">90</td><td title=" (total size 0)

Implementation dependent debugger action.">93</td><td title=" (total size 0)

Implementation dependent debugger action.">93</td><td title=" (total size 0)

Implementation dependent debugger action.">95</td>
        <td> (total size 0)<br><br>Implementation dependent debugger action.</td>
    </tr><tr>
        <td>DebuggerCheckBreak</td><td title=" (total size 0)

Fast check for a debugger break request.">90</td><td title=" (total size 0)

Fast check for a debugger break request.">90</td><td title=" (total size 0)

Fast check for a debugger break request.">91</td><td title=" (total size 0)

Fast check for a debugger break request.">91</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td>
        <td> (total size 0)<br><br>Fast check for a debugger break request.</td>
    </tr><tr>
        <td>Dec</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 - 1 (JS decrement, skips number check)">38</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Arg1 = Arg2 - 1 (JS decrement, skips number check)</td>
    </tr><tr>
        <td>DeclareGlobalVar</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">48</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">48</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">48</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">48</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">48</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">48</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">48</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">48</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">49</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">49</td><td title="UInt32 (string_id) (total size 4)

Declare a global variable by string table index.
The variable will be set to undefined.">51</td>
        <td>UInt32 (string_id) (total size 4)<br><br>Declare a global variable by string table index.<br>The variable will be set to undefined.</td>
    </tr><tr>
        <td>DelById</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">66</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">66</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">66</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">66</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">66</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">66</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">66</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">66</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">69</td>
        <td>Reg8, Reg8, UInt16 (string_id) (total size 4)<br><br>Delete a property by string table index.<br>Arg1 = delete Arg2[stringtable[Arg3]]</td>
    </tr><tr>
        <td>DelByIdLong</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">67</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">68</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">68</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Delete a property by string table index.
Arg1 = delete Arg2[stringtable[Arg3]]">70</td>
        <td>Reg8, Reg8, UInt32 (string_id) (total size 6)<br><br>Delete a property by string table index.<br>Arg1 = delete Arg2[stringtable[Arg3]]</td>
    </tr><tr>
        <td>DelByVal</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">71</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">71</td><td title="Reg8, Reg8, Reg8 (total size 3)

Delete a property by value (when the value is not known at compile time).
Arg1 = delete Arg2[Arg3]">73</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Delete a property by value (when the value is not known at compile time).<br>Arg1 = delete Arg2[Arg3]</td>
    </tr><tr>
        <td>DirectEval</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">87</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">87</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">87</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">87</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">87</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">87</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">87</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">87</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">90</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">90</td><td title="Reg8, Reg8 (total size 2)

ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)
Arg1 is the destination of the return value.
Arg2 is the value to eval.">92</td>
        <td>Reg8, Reg8 (total size 2)<br><br>ES6 18.2.1.1 PerformEval(Arg2, evalRealm, strictCaller=true, direct=true)<br>Arg1 is the destination of the return value.<br>Arg2 is the value to eval.</td>
    </tr><tr>
        <td>Div</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (JS division)">26</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 / Arg3 (JS division)</td>
    </tr><tr>
        <td>DivN</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">26</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (Numeric division, skips number check)">27</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 / Arg3 (Numeric division, skips number check)</td>
    </tr><tr>
        <td>Divi32</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (32-bit signed integer division)">188</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (32-bit signed integer division)">193</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 / Arg3 (32-bit signed integer division)</td>
    </tr><tr>
        <td>Divu32</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (32-bit unsigned integer division)">189</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 / Arg3 (32-bit unsigned integer division)">194</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 / Arg3 (32-bit unsigned integer division)</td>
    </tr><tr>
        <td>Eq</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">13</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">13</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">13</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">13</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">13</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">13</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">13</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">13</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 == Arg3 (JS equality)">14</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 == Arg3 (JS equality)</td>
    </tr><tr>
        <td>GetArgumentsLength</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">115</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">117</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">118</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">118</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">118</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">118</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">118</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">118</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">123</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">123</td><td title="Reg8, Reg8 (total size 2)

Get the length of the &#x27;arguments&#x27; array.
Arg1 is the result.
Arg2 is the lazy loaded register.
Arg1 = arguments.length">128</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Get the length of the &#x27;arguments&#x27; array.<br>Arg1 is the result.<br>Arg2 is the lazy loaded register.<br>Arg1 = arguments.length</td>
    </tr><tr>
        <td>GetArgumentsPropByVal</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">114</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">116</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">117</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">117</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">117</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">117</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">117</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">117</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">122</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">122</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property of the &#x27;arguments&#x27; array by value.
Arg1 is the result.
Arg2 is the index.
Arg3 is the lazy loaded register.
Arg1 = arguments[Arg2]">127</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Get a property of the &#x27;arguments&#x27; array by value.<br>Arg1 is the result.<br>Arg2 is the index.<br>Arg3 is the lazy loaded register.<br>Arg1 = arguments[Arg2]</td>
    </tr><tr>
        <td>GetBuiltinClosure</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, UInt8 (total size 2)

Get a closure from a builtin function.
Arg1 is the destination of the return value.
Arg2 is the builtin number.">87</td><td title="Reg8, UInt8 (total size 2)

Get a closure from a builtin function.
Arg1 is the destination of the return value.
Arg2 is the builtin number.">87</td><td title="Reg8, UInt8 (total size 2)

Get a closure from a builtin function.
Arg1 is the destination of the return value.
Arg2 is the builtin number.">89</td>
        <td>Reg8, UInt8 (total size 2)<br><br>Get a closure from a builtin function.<br>Arg1 is the destination of the return value.<br>Arg2 is the builtin number.</td>
    </tr><tr>
        <td>GetById</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">53</td>
        <td>Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)<br><br>Get an object property by string table index.<br>Arg1 = Arg2[stringtable[Arg4]]<br>Arg3 is a cache index used to speed up the above operation.</td>
    </tr><tr>
        <td>GetByIdLong</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">51</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">52</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">52</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">54</td>
        <td>Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)<br><br>Get an object property by string table index.<br>Arg1 = Arg2[stringtable[Arg4]]<br>Arg3 is a cache index used to speed up the above operation.</td>
    </tr><tr>
        <td>GetByIdShort</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">49</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">49</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">49</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">49</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">49</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">49</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">49</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">49</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">50</td><td title="Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)

Get an object property by string table index.
Arg1 = Arg2[stringtable[Arg4]]
Arg3 is a cache index used to speed up the above operation.">52</td>
        <td>Reg8, Reg8, UInt8, UInt8 (string_id) (total size 4)<br><br>Get an object property by string table index.<br>Arg1 = Arg2[stringtable[Arg4]]<br>Arg3 is a cache index used to speed up the above operation.</td>
    </tr><tr>
        <td>GetByVal</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">68</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">68</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">68</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">68</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">68</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">68</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">68</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">68</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Get a property by value. Constants string values should instead use GetById.
Arg1 = Arg2[Arg3]">71</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Get a property by value. Constants string values should instead use GetById.<br>Arg1 = Arg2[Arg3]</td>
    </tr><tr>
        <td>GetEnvironment</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">38</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">38</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">38</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">38</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">38</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">38</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">38</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">38</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">39</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">39</td><td title="Reg8, UInt8 (total size 2)

Get an environment (scope) from N levels up the stack.
0 is the current environment, 1 is the caller&#x27;s environment, etc.">41</td>
        <td>Reg8, UInt8 (total size 2)<br><br>Get an environment (scope) from N levels up the stack.<br>0 is the current environment, 1 is the caller&#x27;s environment, etc.</td>
    </tr><tr>
        <td>GetGlobalObject</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">45</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">45</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">45</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">45</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">45</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">45</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">45</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">45</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">46</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">46</td><td title="Reg8 (total size 1)

Get the global object (the object in which global variables are stored).">48</td>
        <td>Reg8 (total size 1)<br><br>Get the global object (the object in which global variables are stored).</td>
    </tr><tr>
        <td>GetNewTarget</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">46</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">46</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">46</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">46</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">46</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">46</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">46</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">46</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">47</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">47</td><td title="Reg8 (total size 1)

Obtain the value of NewTarget from the frame.
Arg1 = NewTarget">49</td>
        <td>Reg8 (total size 1)<br><br>Obtain the value of NewTarget from the frame.<br>Arg1 = NewTarget</td>
    </tr><tr>
        <td>GetNextPName</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">74</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">74</td><td title="Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)

Get the next property in the for..in iterator.
Returns Arg1, which is the next property. Undefined if unavailable.
Arg2 is the register that holds array of properties.
Arg3 is the register that holds the object.
Arg4 is the register that holds the iterating index.
Arg5 is the register that holds the size of the property list.">76</td>
        <td>Reg8, Reg8, Reg8, Reg8, Reg8 (total size 5)<br><br>Get the next property in the for..in iterator.<br>Returns Arg1, which is the next property. Undefined if unavailable.<br>Arg2 is the register that holds array of properties.<br>Arg3 is the register that holds the object.<br>Arg4 is the register that holds the iterating index.<br>Arg5 is the register that holds the size of the property list.</td>
    </tr><tr>
        <td>GetPNameList</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">72</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">72</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">72</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">72</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">72</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">72</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">72</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">72</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">73</td><td title="Reg8, Reg8, Reg8, Reg8 (total size 4)

Get the list of properties from an object to implement for..in loop.
Returns Arg1, which is the register that holds array of properties.
Returns Undefined if the object is null/undefined.
Arg2 is the register that holds the object.
Arg3 is the register that holds the iterating index.
Arg4 is the register that holds the size of the property list.">75</td>
        <td>Reg8, Reg8, Reg8, Reg8 (total size 4)<br><br>Get the list of properties from an object to implement for..in loop.<br>Returns Arg1, which is the register that holds array of properties.<br>Returns Undefined if the object is null/undefined.<br>Arg2 is the register that holds the object.<br>Arg3 is the register that holds the iterating index.<br>Arg4 is the register that holds the size of the property list.</td>
    </tr><tr>
        <td>Greater</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt; Arg3 (JS greater-than)">20</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 &gt; Arg3 (JS greater-than)</td>
    </tr><tr>
        <td>GreaterEq</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">20</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">21</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)">21</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 &gt;= Arg3 (JS greater-than-or-equals)</td>
    </tr><tr>
        <td>Inc</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 + 1 (JS increment, skips number check)">37</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Arg1 = Arg2 + 1 (JS increment, skips number check)</td>
    </tr><tr>
        <td>InstanceOf</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">36</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Check whether Arg2 contains Arg3 in its prototype chain.
Note that this is not the same as JS instanceof.
Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)">39</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Check whether Arg2 contains Arg3 in its prototype chain.<br>Note that this is not the same as JS instanceof.<br>Pseudocode: Arg1 = prototypechain(Arg2).contains(Arg3)</td>
    </tr><tr>
        <td>IsIn</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">37</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">38</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">38</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)">40</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 in Arg3 (JS relational &#x27;in&#x27;)</td>
    </tr><tr>
        <td>IteratorBegin</td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8 (total size 2)

Arg1 [out] is the result iterator or index.
Arg2 [in/out] is the source. Output for either the source or next method.
If source is an array with an unmodified [Symbol.iterator], the result is
0. Else the result is source[Symbol.iterator] and the output is the .next()
method on the iterator.
See IR.md for IteratorBeginInst.">127</td><td title="Reg8, Reg8 (total size 2)

Arg1 [out] is the result iterator or index.
Arg2 [in/out] is the source. Output for either the source or next method.
If source is an array with an unmodified [Symbol.iterator], the result is
0. Else the result is source[Symbol.iterator] and the output is the .next()
method on the iterator.
See IR.md for IteratorBeginInst.">127</td><td title="Reg8, Reg8 (total size 2)

Arg1 [out] is the result iterator or index.
Arg2 [in/out] is the source. Output for either the source or next method.
If source is an array with an unmodified [Symbol.iterator], the result is
0. Else the result is source[Symbol.iterator] and the output is the .next()
method on the iterator.
See IR.md for IteratorBeginInst.">132</td><td title="Reg8, Reg8 (total size 2)

Arg1 [out] is the result iterator or index.
Arg2 [in/out] is the source. Output for either the source or next method.
If source is an array with an unmodified [Symbol.iterator], the result is
0. Else the result is source[Symbol.iterator] and the output is the .next()
method on the iterator.
See IR.md for IteratorBeginInst.">132</td><td title="Reg8, Reg8 (total size 2)

Arg1 [out] is the result iterator or index.
Arg2 [in/out] is the source. Output for either the source or next method.
If source is an array with an unmodified [Symbol.iterator], the result is
0. Else the result is source[Symbol.iterator] and the output is the .next()
method on the iterator.
See IR.md for IteratorBeginInst.">137</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Arg1 [out] is the result iterator or index.<br>Arg2 [in/out] is the source. Output for either the source or next method.<br>If source is an array with an unmodified [Symbol.iterator], the result is<br>0. Else the result is source[Symbol.iterator] and the output is the .next()<br>method on the iterator.<br>See IR.md for IteratorBeginInst.</td>
    </tr><tr>
        <td>IteratorClose</td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, UInt8 (total size 2)

Arg1 [in] is the iterator or array index.
Arg2 is a bool indicating whether to ignore the inner exception.
If the iterator is an object, call iterator.return().
If Arg2 is true, ignore exceptions which are thrown by iterator.return().
See IR.md for IteratorCloseInst.">129</td><td title="Reg8, UInt8 (total size 2)

Arg1 [in] is the iterator or array index.
Arg2 is a bool indicating whether to ignore the inner exception.
If the iterator is an object, call iterator.return().
If Arg2 is true, ignore exceptions which are thrown by iterator.return().
See IR.md for IteratorCloseInst.">129</td><td title="Reg8, UInt8 (total size 2)

Arg1 [in] is the iterator or array index.
Arg2 is a bool indicating whether to ignore the inner exception.
If the iterator is an object, call iterator.return().
If Arg2 is true, ignore exceptions which are thrown by iterator.return().
See IR.md for IteratorCloseInst.">134</td><td title="Reg8, UInt8 (total size 2)

Arg1 [in] is the iterator or array index.
Arg2 is a bool indicating whether to ignore the inner exception.
If the iterator is an object, call iterator.return().
If Arg2 is true, ignore exceptions which are thrown by iterator.return().
See IR.md for IteratorCloseInst.">134</td><td title="Reg8, UInt8 (total size 2)

Arg1 [in] is the iterator or array index.
Arg2 is a bool indicating whether to ignore the inner exception.
If the iterator is an object, call iterator.return().
If Arg2 is true, ignore exceptions which are thrown by iterator.return().
See IR.md for IteratorCloseInst.">139</td>
        <td>Reg8, UInt8 (total size 2)<br><br>Arg1 [in] is the iterator or array index.<br>Arg2 is a bool indicating whether to ignore the inner exception.<br>If the iterator is an object, call iterator.return().<br>If Arg2 is true, ignore exceptions which are thrown by iterator.return().<br>See IR.md for IteratorCloseInst.</td>
    </tr><tr>
        <td>IteratorNext</td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 [out] is the result, or undefined if done.
Arg2 [in/out] is the iterator or index.
Arg2 [in] is the source or the next method.
If iterator is undefined, result = undefined.
If iterator is a number:
If iterator is less than source.length, return source[iterator++]
Else iterator = undefined and result = undefined
Else:
n = iterator.next()
If n.done, iterator = undefined and result = undefined.
Else result = n.value
See IR.md for IteratorNextInst.">128</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 [out] is the result, or undefined if done.
Arg2 [in/out] is the iterator or index.
Arg2 [in] is the source or the next method.
If iterator is undefined, result = undefined.
If iterator is a number:
If iterator is less than source.length, return source[iterator++]
Else iterator = undefined and result = undefined
Else:
n = iterator.next()
If n.done, iterator = undefined and result = undefined.
Else result = n.value
See IR.md for IteratorNextInst.">128</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 [out] is the result, or undefined if done.
Arg2 [in/out] is the iterator or index.
Arg2 [in] is the source or the next method.
If iterator is undefined, result = undefined.
If iterator is a number:
If iterator is less than source.length, return source[iterator++]
Else iterator = undefined and result = undefined
Else:
n = iterator.next()
If n.done, iterator = undefined and result = undefined.
Else result = n.value
See IR.md for IteratorNextInst.">133</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 [out] is the result, or undefined if done.
Arg2 [in/out] is the iterator or index.
Arg2 [in] is the source or the next method.
If iterator is undefined, result = undefined.
If iterator is a number:
If iterator is less than source.length, return source[iterator++]
Else iterator = undefined and result = undefined
Else:
n = iterator.next()
If n.done, iterator = undefined and result = undefined.
Else result = n.value
See IR.md for IteratorNextInst.">133</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 [out] is the result, or undefined if done.
Arg2 [in/out] is the iterator or index.
Arg2 [in] is the source or the next method.
If iterator is undefined, result = undefined.
If iterator is a number:
If iterator is less than source.length, return source[iterator++]
Else iterator = undefined and result = undefined
Else:
n = iterator.next()
If n.done, iterator = undefined and result = undefined.
Else result = n.value
See IR.md for IteratorNextInst.">138</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 [out] is the result, or undefined if done.<br>Arg2 [in/out] is the iterator or index.<br>Arg2 [in] is the source or the next method.<br>If iterator is undefined, result = undefined.<br>If iterator is a number:<br>If iterator is less than source.length, return source[iterator++]<br>Else iterator = undefined and result = undefined<br>Else:<br>n = iterator.next()<br>If n.done, iterator = undefined and result = undefined.<br>Else result = n.value<br>See IR.md for IteratorNextInst.</td>
    </tr><tr>
        <td>JEqual</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">177</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">177</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">182</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JEqualLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">178</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">178</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">183</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JGreater</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">143</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JGreaterEqual</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JGreaterEqualLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JGreaterEqualN</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">178</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JGreaterEqualNLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">179</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JGreaterLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">144</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JGreaterN</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JGreaterNLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JLess</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">127</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">136</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">137</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">137</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">137</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">137</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">140</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">140</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JLessEqual</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">135</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">144</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JLessEqualLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">136</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JLessEqualN</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">139</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JLessEqualNLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">140</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JLessLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">128</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">137</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">138</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">138</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">138</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">138</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">141</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">141</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JLessN</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">131</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">140</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">141</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">141</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">141</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">141</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">144</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">144</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JLessNLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">132</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">141</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">142</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">142</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">142</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">142</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotEqual</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">179</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">179</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">184</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotEqualLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">180</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">180</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">185</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotGreater</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">145</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotGreaterEqual</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">176</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotGreaterEqualLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">177</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotGreaterEqualN</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">170</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">180</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotGreaterEqualNLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">171</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">176</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">176</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">181</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotGreaterLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">169</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotGreaterN</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">149</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">158</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">162</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">167</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotGreaterNLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">168</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotLess</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">129</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">138</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">139</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">139</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">139</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">139</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">142</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">142</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotLessEqual</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">137</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotLessEqualLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">138</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">161</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotLessEqualN</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">141</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">150</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">154</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">159</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotLessEqualNLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">142</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">155</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">160</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotLessLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">130</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">139</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">140</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">140</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">140</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">140</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">143</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">143</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">148</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">153</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotLessN</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">133</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">142</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">143</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">143</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">143</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">143</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">146</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">151</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">156</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JNotLessNLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">134</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">143</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">144</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">144</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">144</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">144</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">147</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">152</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">157</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JStrictEqual</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">163</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">172</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">176</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">176</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">181</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">181</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">186</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JStrictEqualLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">164</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">173</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">177</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">177</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">182</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">182</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">187</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JStrictNotEqual</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">165</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">174</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">178</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">178</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">183</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">183</td><td title="Addr8, Reg8, Reg8 (total size 3)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">188</td>
        <td>Addr8, Reg8, Reg8 (total size 3)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>JStrictNotEqualLong</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">166</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">175</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">176</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">176</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">176</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">176</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">179</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">179</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">184</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">184</td><td title="Addr32, Reg8, Reg8 (total size 6)

Not conditionals are required for NaN comparisons
Since we want to be able to reorder targets to allow for fall-throughs,
we need to be able to say &quot;jump when not less than to BB2&quot; instead of
&quot;jump when less than to BB1&quot;.
Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;">189</td>
        <td>Addr32, Reg8, Reg8 (total size 6)<br><br>Not conditionals are required for NaN comparisons<br>Since we want to be able to reorder targets to allow for fall-throughs,<br>we need to be able to say &quot;jump when not less than to BB2&quot; instead of<br>&quot;jump when less than to BB1&quot;.<br>Since NaN comparisons always return false, &quot;not less&quot; != &quot;greater or equal&quot;</td>
    </tr><tr>
        <td>Jmp</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">119</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">126</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">127</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">127</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">127</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">127</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">130</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">130</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">135</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">135</td><td title="Addr8 (total size 1)

Unconditional branch to Arg1.">140</td>
        <td>Addr8 (total size 1)<br><br>Unconditional branch to Arg1.</td>
    </tr><tr>
        <td>JmpFalse</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">123</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">130</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">131</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">131</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">131</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">131</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">134</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">134</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">139</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">139</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">144</td>
        <td>Addr8, Reg8 (total size 2)<br><br>Conditional branches to Arg1 based on Arg2.</td>
    </tr><tr>
        <td>JmpFalseLong</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">124</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">131</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">132</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">132</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">132</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">132</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">135</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">135</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">140</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">140</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">145</td>
        <td>Addr32, Reg8 (total size 5)<br><br>Conditional branches to Arg1 based on Arg2.</td>
    </tr><tr>
        <td>JmpLong</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">120</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">127</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">128</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">128</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">128</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">128</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">131</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">131</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">136</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">136</td><td title="Addr32 (total size 4)

Unconditional branch to Arg1.">141</td>
        <td>Addr32 (total size 4)<br><br>Unconditional branch to Arg1.</td>
    </tr><tr>
        <td>JmpTrue</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">121</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">128</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">129</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">129</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">129</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">129</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">132</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">132</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">137</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">137</td><td title="Addr8, Reg8 (total size 2)

Conditional branches to Arg1 based on Arg2.">142</td>
        <td>Addr8, Reg8 (total size 2)<br><br>Conditional branches to Arg1 based on Arg2.</td>
    </tr><tr>
        <td>JmpTrueLong</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">122</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">129</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">130</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">130</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">130</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">130</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">133</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">133</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">138</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">138</td><td title="Addr32, Reg8 (total size 5)

Conditional branches to Arg1 based on Arg2.">143</td>
        <td>Addr32, Reg8 (total size 5)<br><br>Conditional branches to Arg1 based on Arg2.</td>
    </tr><tr>
        <td>JmpUndefined</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">125</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">132</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">133</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">133</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">133</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">133</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">136</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">136</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">141</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">141</td><td title="Addr8, Reg8 (total size 2)

Jump if the value is undefined.">146</td>
        <td>Addr8, Reg8 (total size 2)<br><br>Jump if the value is undefined.</td>
    </tr><tr>
        <td>JmpUndefinedLong</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">126</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">133</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">134</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">134</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">134</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">134</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">137</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">137</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">142</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">142</td><td title="Addr32, Reg8 (total size 5)

Jump if the value is undefined.">147</td>
        <td>Addr32, Reg8 (total size 5)<br><br>Jump if the value is undefined.</td>
    </tr><tr>
        <td>LShift</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)">31</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 &lt;&lt; Arg3 (JS bitshift left)</td>
    </tr><tr>
        <td>Less</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt; Arg3 (JS less-than)">18</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 &lt; Arg3 (JS less-than)</td>
    </tr><tr>
        <td>LessEq</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">18</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">19</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)">19</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 &lt;= Arg3 (JS less-than-or-equals)</td>
    </tr><tr>
        <td>LoadConstBigInt</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, UInt16 (bigint_id) (total size 3)

Load a constant BigInt value by bigint table index.">111</td>
        <td>Reg8, UInt16 (bigint_id) (total size 3)<br><br>Load a constant BigInt value by bigint table index.</td>
    </tr><tr>
        <td>LoadConstBigIntLongIndex</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, UInt32 (bigint_id) (total size 5)

Load a constant BigInt value by bigint table index.">112</td>
        <td>Reg8, UInt32 (bigint_id) (total size 5)<br><br>Load a constant BigInt value by bigint table index.</td>
    </tr><tr>
        <td>LoadConstDouble</td><td title="Reg8, Double (total size 9)

Load a constant double value.">101</td><td title="Reg8, Double (total size 9)

Load a constant double value.">103</td><td title="Reg8, Double (total size 9)

Load a constant double value.">104</td><td title="Reg8, Double (total size 9)

Load a constant double value.">104</td><td title="Reg8, Double (total size 9)

Load a constant double value.">104</td><td title="Reg8, Double (total size 9)

Load a constant double value.">104</td><td title="Reg8, Double (total size 9)

Load a constant double value.">104</td><td title="Reg8, Double (total size 9)

Load a constant double value.">104</td><td title="Reg8, Double (total size 9)

Load a constant double value.">108</td><td title="Reg8, Double (total size 9)

Load a constant double value.">108</td><td title="Reg8, Double (total size 9)

Load a constant double value.">110</td>
        <td>Reg8, Double (total size 9)<br><br>Load a constant double value.</td>
    </tr><tr>
        <td>LoadConstEmpty</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8 (total size 1)

Load common constants.">111</td><td title="Reg8 (total size 1)

Load common constants.">111</td><td title="Reg8 (total size 1)

Load common constants.">115</td>
        <td>Reg8 (total size 1)<br><br>Load common constants.</td>
    </tr><tr>
        <td>LoadConstFalse</td><td title="Reg8 (total size 1)

Load common constants.">107</td><td title="Reg8 (total size 1)

Load common constants.">109</td><td title="Reg8 (total size 1)

Load common constants.">110</td><td title="Reg8 (total size 1)

Load common constants.">110</td><td title="Reg8 (total size 1)

Load common constants.">110</td><td title="Reg8 (total size 1)

Load common constants.">110</td><td title="Reg8 (total size 1)

Load common constants.">110</td><td title="Reg8 (total size 1)

Load common constants.">110</td><td title="Reg8 (total size 1)

Load common constants.">115</td><td title="Reg8 (total size 1)

Load common constants.">115</td><td title="Reg8 (total size 1)

Load common constants.">119</td>
        <td>Reg8 (total size 1)<br><br>Load common constants.</td>
    </tr><tr>
        <td>LoadConstInt</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">100</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">102</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">103</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">103</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">103</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">103</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">103</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">103</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">107</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">107</td><td title="Reg8, Imm32 (total size 5)

Load a constant integer value.">109</td>
        <td>Reg8, Imm32 (total size 5)<br><br>Load a constant integer value.</td>
    </tr><tr>
        <td>LoadConstNull</td><td title="Reg8 (total size 1)

Load common constants.">105</td><td title="Reg8 (total size 1)

Load common constants.">107</td><td title="Reg8 (total size 1)

Load common constants.">108</td><td title="Reg8 (total size 1)

Load common constants.">108</td><td title="Reg8 (total size 1)

Load common constants.">108</td><td title="Reg8 (total size 1)

Load common constants.">108</td><td title="Reg8 (total size 1)

Load common constants.">108</td><td title="Reg8 (total size 1)

Load common constants.">108</td><td title="Reg8 (total size 1)

Load common constants.">113</td><td title="Reg8 (total size 1)

Load common constants.">113</td><td title="Reg8 (total size 1)

Load common constants.">117</td>
        <td>Reg8 (total size 1)<br><br>Load common constants.</td>
    </tr><tr>
        <td>LoadConstString</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">102</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">104</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">105</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">105</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">105</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">105</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">105</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">105</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">109</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">109</td><td title="Reg8, UInt16 (string_id) (total size 3)

Load a constant string value by string table index.">113</td>
        <td>Reg8, UInt16 (string_id) (total size 3)<br><br>Load a constant string value by string table index.</td>
    </tr><tr>
        <td>LoadConstStringLongIndex</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">103</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">105</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">106</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">106</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">106</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">106</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">106</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">106</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">110</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">110</td><td title="Reg8, UInt32 (string_id) (total size 5)

Load a constant string value by string table index.">114</td>
        <td>Reg8, UInt32 (string_id) (total size 5)<br><br>Load a constant string value by string table index.</td>
    </tr><tr>
        <td>LoadConstTrue</td><td title="Reg8 (total size 1)

Load common constants.">106</td><td title="Reg8 (total size 1)

Load common constants.">108</td><td title="Reg8 (total size 1)

Load common constants.">109</td><td title="Reg8 (total size 1)

Load common constants.">109</td><td title="Reg8 (total size 1)

Load common constants.">109</td><td title="Reg8 (total size 1)

Load common constants.">109</td><td title="Reg8 (total size 1)

Load common constants.">109</td><td title="Reg8 (total size 1)

Load common constants.">109</td><td title="Reg8 (total size 1)

Load common constants.">114</td><td title="Reg8 (total size 1)

Load common constants.">114</td><td title="Reg8 (total size 1)

Load common constants.">118</td>
        <td>Reg8 (total size 1)<br><br>Load common constants.</td>
    </tr><tr>
        <td>LoadConstUInt8</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">99</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">101</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">102</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">102</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">102</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">102</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">102</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">102</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">106</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">106</td><td title="Reg8, UInt8 (total size 2)

Load a constant integer value.">108</td>
        <td>Reg8, UInt8 (total size 2)<br><br>Load a constant integer value.</td>
    </tr><tr>
        <td>LoadConstUndefined</td><td title="Reg8 (total size 1)

Load common constants.">104</td><td title="Reg8 (total size 1)

Load common constants.">106</td><td title="Reg8 (total size 1)

Load common constants.">107</td><td title="Reg8 (total size 1)

Load common constants.">107</td><td title="Reg8 (total size 1)

Load common constants.">107</td><td title="Reg8 (total size 1)

Load common constants.">107</td><td title="Reg8 (total size 1)

Load common constants.">107</td><td title="Reg8 (total size 1)

Load common constants.">107</td><td title="Reg8 (total size 1)

Load common constants.">112</td><td title="Reg8 (total size 1)

Load common constants.">112</td><td title="Reg8 (total size 1)

Load common constants.">116</td>
        <td>Reg8 (total size 1)<br><br>Load common constants.</td>
    </tr><tr>
        <td>LoadConstZero</td><td title="Reg8 (total size 1)

Load common constants.">108</td><td title="Reg8 (total size 1)

Load common constants.">110</td><td title="Reg8 (total size 1)

Load common constants.">111</td><td title="Reg8 (total size 1)

Load common constants.">111</td><td title="Reg8 (total size 1)

Load common constants.">111</td><td title="Reg8 (total size 1)

Load common constants.">111</td><td title="Reg8 (total size 1)

Load common constants.">111</td><td title="Reg8 (total size 1)

Load common constants.">111</td><td title="Reg8 (total size 1)

Load common constants.">116</td><td title="Reg8 (total size 1)

Load common constants.">116</td><td title="Reg8 (total size 1)

Load common constants.">120</td>
        <td>Reg8 (total size 1)<br><br>Load common constants.</td>
    </tr><tr>
        <td>LoadFromEnvironment</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">43</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">43</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">43</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">43</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">43</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">43</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">43</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">43</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt8 (total size 3)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">46</td>
        <td>Reg8, Reg8, UInt8 (total size 3)<br><br>Load a value from an environment.<br>Arg1 is the destination.<br>Arg2 is the environment (as fetched by GetEnvironment).<br>Arg3 is the environment index slot number.</td>
    </tr><tr>
        <td>LoadFromEnvironmentL</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">44</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">45</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">45</td><td title="Reg8, Reg8, UInt16 (total size 4)

Load a value from an environment.
Arg1 is the destination.
Arg2 is the environment (as fetched by GetEnvironment).
Arg3 is the environment index slot number.">47</td>
        <td>Reg8, Reg8, UInt16 (total size 4)<br><br>Load a value from an environment.<br>Arg1 is the destination.<br>Arg2 is the environment (as fetched by GetEnvironment).<br>Arg3 is the environment index slot number.</td>
    </tr><tr>
        <td>LoadParam</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">97</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">99</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">100</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">100</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">100</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">100</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">100</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">100</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">104</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">104</td><td title="Reg8, UInt8 (total size 2)

Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.
Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];">106</td>
        <td>Reg8, UInt8 (total size 2)<br><br>Load a function parameter by index. Starts at 0 with &#x27;this&#x27;.<br>Arg1 = Arg2 == 0 ? this : arguments[Arg2 - 1];</td>
    </tr><tr>
        <td>LoadParamLong</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">98</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">100</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">101</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">101</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">101</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">101</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">101</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">101</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">105</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">105</td><td title="Reg8, UInt32 (total size 5)

Like LoadParam, but allows accessing arguments &gt;= 255.">107</td>
        <td>Reg8, UInt32 (total size 5)<br><br>Like LoadParam, but allows accessing arguments &gt;= 255.</td>
    </tr><tr>
        <td>LoadThisNS</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">110</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">112</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">113</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">113</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">113</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">113</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">113</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">113</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">118</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">118</td><td title="Reg8 (total size 1)

Obtain the raw \c this value and coerce it to an object. Equivalent to:
\code
LoadParam    Arg1, #0
CoerceThisNS Arg1, Arg1
\endcode">122</td>
        <td>Reg8 (total size 1)<br><br>Obtain the raw \c this value and coerce it to an object. Equivalent to:<br>\code<br>LoadParam    Arg1, #0<br>CoerceThisNS Arg1, Arg1<br>\endcode</td>
    </tr><tr>
        <td>Loadi16</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAP16[Arg3 &gt;&gt; 1] (load signed 16-bit integer)">192</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAP16[Arg3 &gt;&gt; 1] (load signed 16-bit integer)">197</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = HEAP16[Arg3 &gt;&gt; 1] (load signed 16-bit integer)</td>
    </tr><tr>
        <td>Loadi32</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAP32[Arg3 &gt;&gt; 2] (load signed 32-bit integer)">194</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAP32[Arg3 &gt;&gt; 2] (load signed 32-bit integer)">199</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = HEAP32[Arg3 &gt;&gt; 2] (load signed 32-bit integer)</td>
    </tr><tr>
        <td>Loadi8</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAP8[Arg3] (load signed 8-bit integer)">190</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAP8[Arg3] (load signed 8-bit integer)">195</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = HEAP8[Arg3] (load signed 8-bit integer)</td>
    </tr><tr>
        <td>Loadu16</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAPU16[Arg3 &gt;&gt; 1] (load unsigned 16-bit integer)">193</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAPU16[Arg3 &gt;&gt; 1] (load unsigned 16-bit integer)">198</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = HEAPU16[Arg3 &gt;&gt; 1] (load unsigned 16-bit integer)</td>
    </tr><tr>
        <td>Loadu32</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAPU32[Arg3 &gt;&gt; 2] (load unsigned 32-bit integer)">195</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAPU32[Arg3 &gt;&gt; 2] (load unsigned 32-bit integer)">200</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = HEAPU32[Arg3 &gt;&gt; 2] (load unsigned 32-bit integer)</td>
    </tr><tr>
        <td>Loadu8</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAPU8[Arg3] (load unsigned 8-bit integer)">191</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = HEAPU8[Arg3] (load unsigned 8-bit integer)">196</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = HEAPU8[Arg3] (load unsigned 8-bit integer)</td>
    </tr><tr>
        <td>Mod</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">27</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 % Arg3 (JS remainder)">28</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 % Arg3 (JS remainder)</td>
    </tr><tr>
        <td>Mov</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">7</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">7</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">7</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">7</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">7</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">7</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">7</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">7</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">8</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">8</td><td title="Reg8, Reg8 (total size 2)

Arg1 = Arg2 (Register copy)">8</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Arg1 = Arg2 (Register copy)</td>
    </tr><tr>
        <td>MovLong</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">8</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">8</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">8</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">8</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">8</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">8</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">8</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">8</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">9</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">9</td><td title="Reg32, Reg32 (total size 8)

Arg1 = Arg2 (Register copy, long index)">9</td>
        <td>Reg32, Reg32 (total size 8)<br><br>Arg1 = Arg2 (Register copy, long index)</td>
    </tr><tr>
        <td>Mul</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">23</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (JS multiplication)">24</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 * Arg3 (JS multiplication)</td>
    </tr><tr>
        <td>Mul32</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (32-bit integer multiplication)">187</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (32-bit integer multiplication)">192</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 * Arg3 (32-bit integer multiplication)</td>
    </tr><tr>
        <td>MulN</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">24</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">25</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)">25</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 * Arg3 (Numeric multiplication, skips number check)</td>
    </tr><tr>
        <td>Negate</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">9</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">9</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">9</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">9</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">9</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">9</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">9</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">9</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = -Arg2 (Unary minus)">10</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Arg1 = -Arg2 (Unary minus)</td>
    </tr><tr>
        <td>Neq</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 != Arg3 (JS inequality)">16</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 != Arg3 (JS inequality)</td>
    </tr><tr>
        <td>NewArray</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">6</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">6</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">6</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">6</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">6</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">6</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">6</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">6</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">7</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">7</td><td title="Reg8, UInt16 (total size 3)

Create a new array of a given size.
Arg1 = new Array(Arg2)">7</td>
        <td>Reg8, UInt16 (total size 3)<br><br>Create a new array of a given size.<br>Arg1 = new Array(Arg2)</td>
    </tr><tr>
        <td>NewArrayWithBuffer</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">4</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">4</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">4</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">4</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">4</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">4</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">4</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">4</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt16 (total size 7)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td>
        <td>Reg8, UInt16, UInt16, UInt16 (total size 7)<br><br>Create an array from a static list of values, as for var=[1,2,3].<br>Any non-constant elements can be set afterwards with PutOwnByIndex.<br>Arg1 is the destination.<br>Arg2 is a preallocation size hint.<br>Arg3 is the number of static elements.<br>Arg4 is the index in the array buffer table.</td>
    </tr><tr>
        <td>NewArrayWithBufferLong</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">5</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">6</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">6</td><td title="Reg8, UInt16, UInt16, UInt32 (total size 9)

Create an array from a static list of values, as for var=[1,2,3].
Any non-constant elements can be set afterwards with PutOwnByIndex.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the array buffer table.">6</td>
        <td>Reg8, UInt16, UInt16, UInt32 (total size 9)<br><br>Create an array from a static list of values, as for var=[1,2,3].<br>Any non-constant elements can be set afterwards with PutOwnByIndex.<br>Arg1 is the destination.<br>Arg2 is a preallocation size hint.<br>Arg3 is the number of static elements.<br>Arg4 is the index in the array buffer table.</td>
    </tr><tr>
        <td>NewObject</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">2</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">2</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">2</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">2</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">2</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">2</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">2</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">2</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">3</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">3</td><td title="Reg8 (total size 1)

Create a new, empty Object using the built-in constructor (regardless of
whether it was overridden).
Arg1 = {}">3</td>
        <td>Reg8 (total size 1)<br><br>Create a new, empty Object using the built-in constructor (regardless of<br>whether it was overridden).<br>Arg1 = {}</td>
    </tr><tr>
        <td>NewObjectWithBuffer</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">0</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">0</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">0</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">0</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">0</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">0</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">0</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">0</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td>
        <td>Reg8, UInt16, UInt16, UInt16, UInt16 (total size 9)<br><br>Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.<br>Any non-constant elements can be set afterwards with PutOwnByInd.<br>Arg1 is the destination.<br>Arg2 is a preallocation size hint.<br>Arg3 is the number of static elements.<br>Arg4 is the index in the object key buffer table.<br>Arg5 is the index in the object val buffer table.</td>
    </tr><tr>
        <td>NewObjectWithBufferLong</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">1</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">2</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">2</td><td title="Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)

Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.
Any non-constant elements can be set afterwards with PutOwnByInd.
Arg1 is the destination.
Arg2 is a preallocation size hint.
Arg3 is the number of static elements.
Arg4 is the index in the object key buffer table.
Arg5 is the index in the object val buffer table.">2</td>
        <td>Reg8, UInt16, UInt16, UInt32, UInt32 (total size 13)<br><br>Create an object from a static map of values, as for var={&#x27;a&#x27;: 3}.<br>Any non-constant elements can be set afterwards with PutOwnByInd.<br>Arg1 is the destination.<br>Arg2 is a preallocation size hint.<br>Arg3 is the number of static elements.<br>Arg4 is the index in the object key buffer table.<br>Arg5 is the index in the object val buffer table.</td>
    </tr><tr>
        <td>NewObjectWithParent</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">3</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">3</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">3</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">3</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">3</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">3</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">3</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">3</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">4</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">4</td><td title="Reg8, Reg8 (total size 2)

Create a new empty Object with the specified parent. If the parent is
null, no parent is used. If the parent is not an object, the builtin
Object.prototype is used. Otherwise the parent itself is used.
Arg1 = the created object
Arg2 = the parent.">4</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Create a new empty Object with the specified parent. If the parent is<br>null, no parent is used. If the parent is not an object, the builtin<br>Object.prototype is used. Otherwise the parent itself is used.<br>Arg1 = the created object<br>Arg2 = the parent.</td>
    </tr><tr>
        <td>Not</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">10</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">11</td><td title="Reg8, Reg8 (total size 2)

Arg1 = !Arg2 (Boolean not)">11</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Arg1 = !Arg2 (Boolean not)</td>
    </tr><tr>
        <td>ProfilePoint</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">91</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">91</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">92</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">92</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">92</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">92</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">92</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">92</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">95</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">95</td><td title="UInt16 (total size 2)

Define a profile point.
Arg1 is the function local profile point index. The first one will have the
largest index. If there are more than 2^16 profile points in the function,
all the overflowed profile points have index zero.">97</td>
        <td>UInt16 (total size 2)<br><br>Define a profile point.<br>Arg1 is the function local profile point index. The first one will have the<br>largest index. If there are more than 2^16 profile points in the function,<br>all the overflowed profile points have index zero.</td>
    </tr><tr>
        <td>PutById</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">54</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">54</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">54</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">54</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">54</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">54</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">54</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">54</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">57</td>
        <td>Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)<br><br>Set an object property by string index.<br>Arg1[stringtable[Arg4]] = Arg2.</td>
    </tr><tr>
        <td>PutByIdLong</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">55</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">56</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">56</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index.
Arg1[stringtable[Arg4]] = Arg2.">58</td>
        <td>Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)<br><br>Set an object property by string index.<br>Arg1[stringtable[Arg4]] = Arg2.</td>
    </tr><tr>
        <td>PutByVal</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">69</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">70</td><td title="Reg8, Reg8, Reg8 (total size 3)

Set a property by value. Constant string values should instead use GetById
(unless they are array indices according to ES5.1 section 15.4, in which
case this is still the right opcode).
Arg1[Arg2] = Arg3">72</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Set a property by value. Constant string values should instead use GetById<br>(unless they are array indices according to ES5.1 section 15.4, in which<br>case this is still the right opcode).<br>Arg1[Arg2] = Arg3</td>
    </tr><tr>
        <td>PutNewOwnById</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td>
        <td>Reg8, Reg8, UInt16 (string_id) (total size 4)<br><br>Create a new own property on an object. This is similar to PutById, but<br>the destination must be an object, it only deals with own properties,<br>ignoring the prototype chain, and the property must not already be defined.<br>Similarly to PutById, the property name cannot be a valid array index.<br>Arg1 is the destination object, which is known to be an object.<br>Arg2 is the value to write.<br>Arg3 is the string table ID of the property name.<br>Arg1[stringtable[Arg3]] = Arg2</td>
    </tr><tr>
        <td>PutNewOwnByIdLong</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">60</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">63</td>
        <td>Reg8, Reg8, UInt32 (string_id) (total size 6)<br><br>Create a new own property on an object. This is similar to PutById, but<br>the destination must be an object, it only deals with own properties,<br>ignoring the prototype chain, and the property must not already be defined.<br>Similarly to PutById, the property name cannot be a valid array index.<br>Arg1 is the destination object, which is known to be an object.<br>Arg2 is the value to write.<br>Arg3 is the string table ID of the property name.<br>Arg1[stringtable[Arg3]] = Arg2</td>
    </tr><tr>
        <td>PutNewOwnByIdShort</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">58</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">58</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">58</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">58</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">58</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">58</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">58</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">58</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">59</td><td title="Reg8, Reg8, UInt8 (string_id) (total size 3)

Create a new own property on an object. This is similar to PutById, but
the destination must be an object, it only deals with own properties,
ignoring the prototype chain, and the property must not already be defined.
Similarly to PutById, the property name cannot be a valid array index.
Arg1 is the destination object, which is known to be an object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td>
        <td>Reg8, Reg8, UInt8 (string_id) (total size 3)<br><br>Create a new own property on an object. This is similar to PutById, but<br>the destination must be an object, it only deals with own properties,<br>ignoring the prototype chain, and the property must not already be defined.<br>Similarly to PutById, the property name cannot be a valid array index.<br>Arg1 is the destination object, which is known to be an object.<br>Arg2 is the value to write.<br>Arg3 is the string table ID of the property name.<br>Arg1[stringtable[Arg3]] = Arg2</td>
    </tr><tr>
        <td>PutNewOwnNEById</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">61</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt16 (string_id) (total size 4)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">64</td>
        <td>Reg8, Reg8, UInt16 (string_id) (total size 4)<br><br>Create a new non-enumerable own property on an object. This is the same as<br>PutNewOwnById, but creates the property with different enumerability.<br>Arg1 is the destination object.<br>Arg2 is the value to write.<br>Arg3 is the string table ID of the property name.<br>Arg1[stringtable[Arg3]] = Arg2</td>
    </tr><tr>
        <td>PutNewOwnNEByIdLong</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">62</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">63</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">63</td><td title="Reg8, Reg8, UInt32 (string_id) (total size 6)

Create a new non-enumerable own property on an object. This is the same as
PutNewOwnById, but creates the property with different enumerability.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the string table ID of the property name.
Arg1[stringtable[Arg3]] = Arg2">65</td>
        <td>Reg8, Reg8, UInt32 (string_id) (total size 6)<br><br>Create a new non-enumerable own property on an object. This is the same as<br>PutNewOwnById, but creates the property with different enumerability.<br>Arg1 is the destination object.<br>Arg2 is the value to write.<br>Arg3 is the string table ID of the property name.<br>Arg1[stringtable[Arg3]] = Arg2</td>
    </tr><tr>
        <td>PutOwnByIndex</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">63</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">63</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">63</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">63</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">63</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">63</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">63</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">63</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt8 (total size 3)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">66</td>
        <td>Reg8, Reg8, UInt8 (total size 3)<br><br>Assign a value to a constant integer own property which will be created as<br>enumerable. This is used (potentially in conjunction with<br>NewArrayWithBuffer) for arr=[foo,bar] initializations.<br>Arg1[Arg3] = Arg2;</td>
    </tr><tr>
        <td>PutOwnByIndexL</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">64</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, UInt32 (total size 6)

Assign a value to a constant integer own property which will be created as
enumerable. This is used (potentially in conjunction with
NewArrayWithBuffer) for arr=[foo,bar] initializations.
Arg1[Arg3] = Arg2;">67</td>
        <td>Reg8, Reg8, UInt32 (total size 6)<br><br>Assign a value to a constant integer own property which will be created as<br>enumerable. This is used (potentially in conjunction with<br>NewArrayWithBuffer) for arr=[foo,bar] initializations.<br>Arg1[Arg3] = Arg2;</td>
    </tr><tr>
        <td>PutOwnByVal</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">65</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">66</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">66</td><td title="Reg8, Reg8, Reg8, UInt8 (total size 4)

Set an own property identified by value.
Arg1 is the destination object.
Arg2 is the value to write.
Arg3 is the property name.
Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,
non-enumerable otherwise.
Arg1[Arg3] = Arg2;">68</td>
        <td>Reg8, Reg8, Reg8, UInt8 (total size 4)<br><br>Set an own property identified by value.<br>Arg1 is the destination object.<br>Arg2 is the value to write.<br>Arg3 is the property name.<br>Arg4 : bool -&gt; enumerable. If true, the property is created as enumerable,<br>non-enumerable otherwise.<br>Arg1[Arg3] = Arg2;</td>
    </tr><tr>
        <td>PutOwnGetterSetterByVal</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">71</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">71</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">71</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">71</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">71</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">71</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">71</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">71</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">72</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">72</td><td title="Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)

Add a getter and a setter for a property by value.
Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).
Arg1 is the target object which will have a property defined.
Arg2 is the property name
Arg3 is the getter closure or undefined
Arg4 is the setter closure or undefined
Arg5 : boolean - if true, the property will be enumerable.">74</td>
        <td>Reg8, Reg8, Reg8, Reg8, UInt8 (total size 5)<br><br>Add a getter and a setter for a property by value.<br>Object.defineProperty(Arg1, Arg2, { get: Arg3, set: Arg4 }).<br>Arg1 is the target object which will have a property defined.<br>Arg2 is the property name<br>Arg3 is the getter closure or undefined<br>Arg4 is the setter closure or undefined<br>Arg5 : boolean - if true, the property will be enumerable.</td>
    </tr><tr>
        <td>RShift</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">31</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)">32</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 &gt;&gt; Arg3 (JS signed bitshift right)</td>
    </tr><tr>
        <td>ReifyArguments</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">116</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">118</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">119</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">119</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">119</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">119</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">119</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">119</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">124</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">124</td><td title="Reg8 (total size 1)

Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.
Arg1 is the lazy loaded register, which afterwards will contain a proper
object that can be used by non-*Arguments* opcodes like Return.">129</td>
        <td>Reg8 (total size 1)<br><br>Create an actual &#x27;arguments&#x27; array, if get-by-index and length isn&#x27;t enough.<br>Arg1 is the lazy loaded register, which afterwards will contain a proper<br>object that can be used by non-*Arguments* opcodes like Return.</td>
    </tr><tr>
        <td>ResumeGenerator</td><td></td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">122</td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">123</td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">123</td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">123</td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">123</td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">123</td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">123</td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">128</td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">128</td><td title="Reg8, Reg8 (total size 2)

Resume generator by performing one of the following user-requested actions:
- next(val): Set Arg1 to val, Arg2 to false, run next instruction
- return(val): Set Arg1 to val, Arg2 to true, run next instruction
- throw(val): Throw val as an error
Arg1 is the result provided by the user.
Arg2 is a boolean which is true if the user requested a return().">133</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Resume generator by performing one of the following user-requested actions:<br>- next(val): Set Arg1 to val, Arg2 to false, run next instruction<br>- return(val): Set Arg1 to val, Arg2 to true, run next instruction<br>- throw(val): Throw val as an error<br>Arg1 is the result provided by the user.<br>Arg2 is a boolean which is true if the user requested a return().</td>
    </tr><tr>
        <td>Ret</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">85</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">85</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">85</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">85</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">85</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">85</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">85</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">85</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">88</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">88</td><td title="Reg8 (total size 1)

Return a value from the current function.
return Arg1;">90</td>
        <td>Reg8 (total size 1)<br><br>Return a value from the current function.<br>return Arg1;</td>
    </tr><tr>
        <td>SaveGenerator</td><td></td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">134</td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">135</td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">135</td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">135</td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">135</td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">138</td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">138</td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">143</td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">143</td><td title="Addr8 (total size 1)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">148</td>
        <td>Addr8 (total size 1)<br><br>Save the provided value, yield, and signal the VM to restart execution<br>at the provided target.</td>
    </tr><tr>
        <td>SaveGeneratorLong</td><td></td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">135</td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">136</td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">136</td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">136</td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">136</td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">139</td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">139</td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">144</td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">144</td><td title="Addr32 (total size 4)

Save the provided value, yield, and signal the VM to restart execution
at the provided target.">149</td>
        <td>Addr32 (total size 4)<br><br>Save the provided value, yield, and signal the VM to restart execution<br>at the provided target.</td>
    </tr><tr>
        <td>SelectObject</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">96</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">98</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">99</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">99</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">99</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">99</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">99</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">99</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">103</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">103</td><td title="Reg8, Reg8, Reg8 (total size 3)

Choose the result of a constructor: &#x27;this&#x27; or a returned object.
Arg1 is the result.
Arg2 is the &#x27;this&#x27; object used for the constructor.
Arg3 is the constructor&#x27;s return value.
Arg1 = Arg3 instanceof Object ? Arg3 : Arg2">105</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Choose the result of a constructor: &#x27;this&#x27; or a returned object.<br>Arg1 is the result.<br>Arg2 is the &#x27;this&#x27; object used for the constructor.<br>Arg3 is the constructor&#x27;s return value.<br>Arg1 = Arg3 instanceof Object ? Arg3 : Arg2</td>
    </tr><tr>
        <td>StartGenerator</td><td></td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">121</td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">122</td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">122</td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">122</td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">122</td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">122</td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">122</td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">127</td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">127</td><td title=" (total size 0)

Start the generator by jumping to the next instruction to begin.
Restore the stack frame if this generator has previously been suspended.">132</td>
        <td> (total size 0)<br><br>Start the generator by jumping to the next instruction to begin.<br>Restore the stack frame if this generator has previously been suspended.</td>
    </tr><tr>
        <td>Store16</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

HEAP16[Arg2] = Arg3 (store signed or unsigned 16-bit integer)">197</td><td title="Reg8, Reg8, Reg8 (total size 3)

HEAP16[Arg2] = Arg3 (store signed or unsigned 16-bit integer)">202</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>HEAP16[Arg2] = Arg3 (store signed or unsigned 16-bit integer)</td>
    </tr><tr>
        <td>Store32</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

HEAP32[Arg2] = Arg3 (store signed or unsigned 32-bit integer)">198</td><td title="Reg8, Reg8, Reg8 (total size 3)

HEAP32[Arg2] = Arg3 (store signed or unsigned 32-bit integer)">203</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>HEAP32[Arg2] = Arg3 (store signed or unsigned 32-bit integer)</td>
    </tr><tr>
        <td>Store8</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

HEAP8[Arg2] = Arg3 (store signed or unsigned 8-bit integer)">196</td><td title="Reg8, Reg8, Reg8 (total size 3)

HEAP8[Arg2] = Arg3 (store signed or unsigned 8-bit integer)">201</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>HEAP8[Arg2] = Arg3 (store signed or unsigned 8-bit integer)</td>
    </tr><tr>
        <td>StoreNPToEnvironment</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">44</td>
        <td>Reg8, UInt8, Reg8 (total size 3)<br><br>Store a value in an environment.<br>StoreNPToEnvironment[L] store a non-pointer value in an environment<br>Arg1 is the environment (as fetched by GetEnvironment).<br>Arg2 is the environment index slot number.<br>Arg3 is the value.</td>
    </tr><tr>
        <td>StoreNPToEnvironmentL</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">43</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">43</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">45</td>
        <td>Reg8, UInt16, Reg8 (total size 4)<br><br>Store a value in an environment.<br>StoreNPToEnvironment[L] store a non-pointer value in an environment<br>Arg1 is the environment (as fetched by GetEnvironment).<br>Arg2 is the environment index slot number.<br>Arg3 is the value.</td>
    </tr><tr>
        <td>StoreToEnvironment</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">39</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">39</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">39</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">39</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">39</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">39</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">39</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">39</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt8, Reg8 (total size 3)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">42</td>
        <td>Reg8, UInt8, Reg8 (total size 3)<br><br>Store a value in an environment.<br>StoreNPToEnvironment[L] store a non-pointer value in an environment<br>Arg1 is the environment (as fetched by GetEnvironment).<br>Arg2 is the environment index slot number.<br>Arg3 is the value.</td>
    </tr><tr>
        <td>StoreToEnvironmentL</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">40</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">41</td><td title="Reg8, UInt16, Reg8 (total size 4)

Store a value in an environment.
StoreNPToEnvironment[L] store a non-pointer value in an environment
Arg1 is the environment (as fetched by GetEnvironment).
Arg2 is the environment index slot number.
Arg3 is the value.">43</td>
        <td>Reg8, UInt16, Reg8 (total size 4)<br><br>Store a value in an environment.<br>StoreNPToEnvironment[L] store a non-pointer value in an environment<br>Arg1 is the environment (as fetched by GetEnvironment).<br>Arg2 is the environment index slot number.<br>Arg3 is the value.</td>
    </tr><tr>
        <td>StrictEq</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">14</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">15</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 === Arg3 (JS strict equality)">15</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 === Arg3 (JS strict equality)</td>
    </tr><tr>
        <td>StrictNeq</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">16</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">17</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 !== Arg3 (JS strict inequality)">17</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 !== Arg3 (JS strict inequality)</td>
    </tr><tr>
        <td>Sub</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">28</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (JS subtraction)">29</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 - Arg3 (JS subtraction)</td>
    </tr><tr>
        <td>Sub32</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (32-bit integer subtraction)">186</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (32-bit integer subtraction)">191</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 - Arg3 (32-bit integer subtraction)</td>
    </tr><tr>
        <td>SubN</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">29</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">30</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)">30</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 - Arg3 (Numeric subtraction, skips number check)</td>
    </tr><tr>
        <td>SwitchImm</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">118</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">120</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">121</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">121</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">121</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">121</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">121</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">121</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">126</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">126</td><td title="Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)

Jump table switch - using a table of offset, jump to the offset of the given
input or to the default block if out of range (or not right type)
Arg 1 is the value to be branched upon
Arg 2 is the relative offset of the jump table to be used by this
instruction. Jump tables are appended to the bytecode. Arg 3 is the relative
offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is
less than this value jmp to
default block
Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to
default block.
Given the above, the jump table entry for a given value (that is in range)
is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid
wasting space when compiling denses switches that do not start at zero. Note
that Arg2 is *unaligned* it is dynamically aligned at runtime.">131</td>
        <td>Reg8, UInt32, Addr32, UInt32, UInt32 (total size 17)<br><br>Jump table switch - using a table of offset, jump to the offset of the given<br>input or to the default block if out of range (or not right type)<br>Arg 1 is the value to be branched upon<br>Arg 2 is the relative offset of the jump table to be used by this<br>instruction. Jump tables are appended to the bytecode. Arg 3 is the relative<br>offset for the &quot;default&quot; jump. Arg 4 is the unsigned min value, if arg 1 is<br>less than this value jmp to<br>default block<br>Arg 5 is the unsigned max value, if arg 1 is greater than this value jmp to<br>default block.<br>Given the above, the jump table entry for a given value (that is in range)<br>is located at offset ip + arg2 + arg1 - arg4. We subtract arg4 to avoid<br>wasting space when compiling denses switches that do not start at zero. Note<br>that Arg2 is *unaligned* it is dynamically aligned at runtime.</td>
    </tr><tr>
        <td>Throw</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">88</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">88</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">88</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">88</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">88</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">88</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">88</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">88</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">91</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">91</td><td title="Reg8 (total size 1)

Throw an exception.
throw Arg1;">93</td>
        <td>Reg8 (total size 1)<br><br>Throw an exception.<br>throw Arg1;</td>
    </tr><tr>
        <td>ThrowIfEmpty</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8 (total size 2)

If Arg2 is Empty, throw ReferenceError, otherwise move it into Arg1.
Arg1 is the destination of the return value
Arg2 is the value to check">92</td><td title="Reg8, Reg8 (total size 2)

If Arg2 is Empty, throw ReferenceError, otherwise move it into Arg1.
Arg1 is the destination of the return value
Arg2 is the value to check">92</td><td title="Reg8, Reg8 (total size 2)

If Arg2 is Empty, throw ReferenceError, otherwise move it into Arg1.
Arg1 is the destination of the return value
Arg2 is the value to check">94</td>
        <td>Reg8, Reg8 (total size 2)<br><br>If Arg2 is Empty, throw ReferenceError, otherwise move it into Arg1.<br>Arg1 is the destination of the return value<br>Arg2 is the value to check</td>
    </tr><tr>
        <td>ThrowIfUndefinedInst</td><td></td><td></td><td title="Reg8 (total size 1)

Throw ReferenceError if the operand is HermesValue::undefined">89</td><td title="Reg8 (total size 1)

Throw ReferenceError if the operand is HermesValue::undefined">89</td><td title="Reg8 (total size 1)

Throw ReferenceError if the operand is HermesValue::undefined">89</td><td title="Reg8 (total size 1)

Throw ReferenceError if the operand is HermesValue::undefined">89</td><td title="Reg8 (total size 1)

Throw ReferenceError if the operand is HermesValue::undefined">89</td><td title="Reg8 (total size 1)

Throw ReferenceError if the operand is HermesValue::undefined">89</td><td></td><td></td><td></td>
        <td>Reg8 (total size 1)<br><br>Throw ReferenceError if the operand is HermesValue::undefined</td>
    </tr><tr>
        <td>ToInt32</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">112</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">114</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">115</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">115</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">115</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">115</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">115</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">115</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">120</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">120</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a 32-bit signed integer.
Arg1 = Arg2 | 0">125</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Convert a value to a 32-bit signed integer.<br>Arg1 = Arg2 | 0</td>
    </tr><tr>
        <td>ToNumber</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">111</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">113</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">114</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">114</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">114</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">114</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">114</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">114</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">119</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">119</td><td title="Reg8, Reg8 (total size 2)

Convert a value to a number.
Arg1 = Arg2 - 0">123</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Convert a value to a number.<br>Arg1 = Arg2 - 0</td>
    </tr><tr>
        <td>ToNumeric</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td title="Reg8, Reg8 (total size 2)

Convert a value to a numberic.
Arg1 = ToNumeric(Arg2)">124</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Convert a value to a numberic.<br>Arg1 = ToNumeric(Arg2)</td>
    </tr><tr>
        <td>TryGetById</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">52</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">52</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">52</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">52</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">52</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">52</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">52</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">52</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">55</td>
        <td>Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)<br><br>Get an object property by string table index, or throw if not found.<br>This is similar to GetById, but intended for use with global variables<br>where Arg2 = GetGlobalObject.</td>
    </tr><tr>
        <td>TryGetByIdLong</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">53</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">54</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">54</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Get an object property by string table index, or throw if not found.
This is similar to GetById, but intended for use with global variables
where Arg2 = GetGlobalObject.">56</td>
        <td>Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)<br><br>Get an object property by string table index, or throw if not found.<br>This is similar to GetById, but intended for use with global variables<br>where Arg2 = GetGlobalObject.</td>
    </tr><tr>
        <td>TryPutById</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">56</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">56</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">56</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">56</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">56</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">56</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">56</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">56</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">59</td>
        <td>Reg8, Reg8, UInt8, UInt16 (string_id) (total size 5)<br><br>Set an object property by string index, or throw if undeclared.<br>This is similar to PutById, but intended for use with global variables<br>where Arg1 = GetGlobalObject.</td>
    </tr><tr>
        <td>TryPutByIdLong</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">57</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">58</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">58</td><td title="Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)

Set an object property by string index, or throw if undeclared.
This is similar to PutById, but intended for use with global variables
where Arg1 = GetGlobalObject.">60</td>
        <td>Reg8, Reg8, UInt8, UInt32 (string_id) (total size 7)<br><br>Set an object property by string index, or throw if undeclared.<br>This is similar to PutById, but intended for use with global variables<br>where Arg1 = GetGlobalObject.</td>
    </tr><tr>
        <td>TypeOf</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">12</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">13</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">13</td><td title="Reg8, Reg8 (total size 2)

Arg1 = typeof Arg2 (JS typeof)">13</td>
        <td>Reg8, Reg8 (total size 2)<br><br>Arg1 = typeof Arg2 (JS typeof)</td>
    </tr><tr>
        <td>URshift</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">32</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">33</td><td title="Reg8, Reg8, Reg8 (total size 3)

Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)">33</td>
        <td>Reg8, Reg8, Reg8 (total size 3)<br><br>Arg1 = Arg2 &gt;&gt;&gt; Arg3 (JS unsigned bitshift right)</td>
    </tr><tr>
        <td>Unreachable</td><td title=" (total size 0)

Unreachable opcode for stubs and similar.">92</td><td title=" (total size 0)

Unreachable opcode for stubs and similar.">92</td><td title=" (total size 0)

Unreachable opcode for stubs and similar.">93</td><td title=" (total size 0)

Unreachable opcode for stubs and similar.">93</td><td title=" (total size 0)

Unreachable opcode for stubs and similar.">93</td><td title=" (total size 0)

Unreachable opcode for stubs and similar.">93</td><td title=" (total size 0)

Unreachable opcode for stubs and similar.">93</td><td title=" (total size 0)

Unreachable opcode for stubs and similar.">93</td><td class="changed" title=" (total size 0)

Unreachable opcode for stubs and similar. This is first so that it has the
value zero.">0</td><td title=" (total size 0)

Unreachable opcode for stubs and similar. This is first so that it has the
value zero.">0</td><td title=" (total size 0)

Unreachable opcode for stubs and similar. This is first so that it has the
value zero.">0</td>
        <td> (total size 0)<br><br>Unreachable opcode for stubs and similar. This is first so that it has the<br>value zero.</td>
    </tr>    </body>
</html>
